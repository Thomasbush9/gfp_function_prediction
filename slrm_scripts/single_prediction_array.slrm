#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=16
#SBATCH --gpus-per-node=1
#SBATCH --mem=256GB
#SBATCH --partition=kempner_requeue
#SBATCH --account=kempner_bsabatini_lab
#SBATCH --time=4:00:00
#SBATCH --mail-type=ALL
#SBATCH --mail-user=thomasbush52@gmail.com
# Use array-aware log names to avoid clobbering:
#SBATCH --output=/n/home06/tbush/job_logs/%x.%A_%a.out


set -euo pipefail

# Select this task's chunk file from the manifest
: "${SLURM_ARRAY_TASK_ID:?Need SLURM_ARRAY_TASK_ID}"
: "${MANIFEST:?Need MANIFEST exported from sbatch}"
: "${BASE_OUTPUT_DIR:?Need BASE_OUTPUT_DIR exported from sbatch}"

LIST_FILE="$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$MANIFEST")"
if [[ -z "${LIST_FILE}" || ! -s "${LIST_FILE}" ]]; then
  echo "Task ${SLURM_ARRAY_TASK_ID}: missing or empty LIST_FILE from manifest."
  exit 1
fi

JOB_ID="${SLURM_ARRAY_JOB_ID:-${SLURM_JOB_ID:-manual}}"
TASK_ID="${SLURM_ARRAY_TASK_ID:-0}"

RUN_TAG="${JOB_ID}_${TASK_ID}"
OUTPUT_DIR="${BASE_OUTPUT_DIR}/${RUN_TAG}"
TEMP_FASTA_DIR_BASE="${OUTPUT_DIR}/temp"
MMSEQ2_DB="/n/holylfs06/LABS/kempner_shared/Everyone/workflow/boltz/mmseq2_db"
COLABFOLD_OUTPUT_BASE="${OUTPUT_DIR}/msa"
BOLTZ_CACHE="/n/holylfs06/LABS/kempner_shared/Everyone/workflow/boltz/boltz_db"
BOLTZ_OUTPUT_BASE="${OUTPUT_DIR}/boltz"
THREADS=${SLURM_CPUS_PER_TASK:-1}

mkdir -p "$COLABFOLD_OUTPUT_BASE" "$BOLTZ_OUTPUT_BASE" "$TEMP_FASTA_DIR_BASE"

# ============================================================================
# JIT Cache Setup - Shared persistent cache + task-local TMPDIR
# ============================================================================

# Global shared JIT cache root (persistent, survives preemption)
JIT_CACHE_ROOT="/n/home06/tbush/boltz_jit_cache"
# Optionally version by CUDA/driver/code if needed, e.g.:
# JIT_CACHE_ROOT="${JIT_CACHE_ROOT}_cuda12.9_$(git rev-parse --short HEAD)"

# Create shared cache directories (idempotent, safe for concurrent access)
mkdir -p "$JIT_CACHE_ROOT"/{triton,inductor,cuda,xdg}

# Task-local TMPDIR for temporary files/spills (node-local, fast)
CACHE_BASE="${SLURM_TMPDIR:-/tmp}/boltz_cache_${USER}_${JOB_ID}_${TASK_ID}"

# If this task's tmpdir exists from a previous crash/preemption, clean it
if [ -d "$CACHE_BASE" ]; then
    echo "Removing existing task tmpdir from previous run..."
    rm -rf "$CACHE_BASE"
fi

# Create task-local tmpdir
mkdir -p "$CACHE_BASE"
export TMPDIR="$CACHE_BASE/tmp"
mkdir -p "$TMPDIR"

# Point JIT caches to shared persistent location
export TRITON_CACHE_DIR="$JIT_CACHE_ROOT/triton"
export TORCHINDUCTOR_CACHE_DIR="$JIT_CACHE_ROOT/inductor"
export CUDA_CACHE_PATH="$JIT_CACHE_ROOT/cuda"
export XDG_CACHE_HOME="$JIT_CACHE_ROOT/xdg"

# Cleanup only task-local TMPDIR on exit (shared cache persists)
cleanup_tmp() {
    echo "Cleaning up task-local tmpdir..."
    rm -rf "$CACHE_BASE" 2>/dev/null || true
}
trap cleanup_tmp EXIT TERM INT

echo "Shared JIT cache root: $JIT_CACHE_ROOT"
echo "Task-local tmpdir: $TMPDIR"


export CUDA_VISIBLE_DEVICES=0
export NUM_GPU_DEVICES=1

# Load required modules
module load python/3.12.8-fasrc01 gcc/14.2.0-fasrc01 cuda/12.9.1-fasrc01 cudnn/9.10.2.21_cuda12-fasrc01
export PATH="/n/holylfs06/LABS/kempner_shared/Everyone/common_envs/miniconda3/envs/boltz/localcolabfold/colabfold-conda/bin:$PATH"
export COLABFOLD_DB=/n/holylfs06/LABS/kempner_shared/Everyone/workflow/boltz/colabfold_db

echo "Task ${SLURM_ARRAY_TASK_ID}: LIST_FILE=${LIST_FILE}"
echo "Outputs -> ${OUTPUT_DIR}"
echo "Threads -> ${THREADS}"

while IFS= read -r INPUT_FASTA; do
  [[ -z "$INPUT_FASTA" ]] && continue

    BASENAME=$(basename "$INPUT_FASTA" .fa)   # strip extension for naming
    COLABFOLD_OUTPUT_DIR="${COLABFOLD_OUTPUT_BASE}/${BASENAME}"
    BOLTZ_OUTPUT_DIR="${BOLTZ_OUTPUT_BASE}/${BASENAME}"
    TEMP_FASTA_DIR="${TEMP_FASTA_DIR_BASE}/${BASENAME}"
    TEMP_FASTA="${TEMP_FASTA_DIR}/${BASENAME}_prot_pipeline.fasta"

    echo "==============================================="
    echo "Processing: $INPUT_FASTA"
    echo "Output dirs: $COLABFOLD_OUTPUT_DIR | $BOLTZ_OUTPUT_DIR"
    echo "==============================================="

    mkdir -p "$COLABFOLD_OUTPUT_DIR" "$BOLTZ_OUTPUT_DIR" "$TEMP_FASTA_DIR"

    # STEP 1: ColabFold search
    colabfold_search "$INPUT_FASTA" "$MMSEQ2_DB" "$COLABFOLD_OUTPUT_DIR" --thread "$THREADS" --gpu 1
    if [ $? -ne 0 ]; then
        echo "ERROR: ColabFold search failed for $INPUT_FASTA"
        continue
    fi

    # STEP 2: Find a3m file
    HEADER=$(head -n1 "$INPUT_FASTA")
    PROTEIN_PREFIX=$(echo "$HEADER" | sed 's/^>//' | sed 's/|/_/g')
    A3M_FILE="${COLABFOLD_OUTPUT_DIR}/${PROTEIN_PREFIX}.a3m"
    if [ ! -f "$A3M_FILE" ]; then
        A3M_FILE=$(find "$COLABFOLD_OUTPUT_DIR" -name "*.a3m" | head -n1)
        if [ -z "$A3M_FILE" ]; then
            echo "No a3m found for $INPUT_FASTA"
            continue
        fi
    fi

    # STEP 3: Create Boltz FASTA
    A3M_ABSOLUTE=$(realpath "$A3M_FILE")
    ORIGINAL_HEADER=$(head -n1 "$INPUT_FASTA")
    SEQUENCE=$(tail -n+2 "$INPUT_FASTA")
    echo "${ORIGINAL_HEADER}${A3M_ABSOLUTE}" > "$TEMP_FASTA"
    echo "$SEQUENCE" >> "$TEMP_FASTA"

    # STEP 4: Run Boltz
    mamba activate /n/holylfs06/LABS/kempner_shared/Everyone/common_envs/miniconda3/envs/boltz

    boltz predict "$TEMP_FASTA" --cache "$BOLTZ_CACHE" --out_dir "$BOLTZ_OUTPUT_DIR" --devices $NUM_GPU_DEVICES --accelerator gpu
    status=$?

    if [ $status -ne 0 ]; then
        echo "WARN: boltz predict failed once (status=$status). Retrying with adjusted settings (shared JIT cache preserved)..."
        sleep 2
        boltz predict "$TEMP_FASTA" --cache "$BOLTZ_CACHE" --out_dir "$BOLTZ_OUTPUT_DIR" \
            --devices $NUM_GPU_DEVICES --accelerator gpu --recycling_steps 10 --diffusion_samples 25
        status=$?
    fi

    if [ $status -ne 0 ]; then
        echo "ERROR: Boltz failed for $INPUT_FASTA"
        continue
    fi

done < "$LIST_FILE"

echo "==============================================="
echo "All jobs from $LIST_FILE finished"
echo "==============================================="
