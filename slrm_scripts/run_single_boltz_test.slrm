#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=16
#SBATCH --gres=gpu:2
#SBATCH --mem=256GB
#SBATCH --partition=kempner_h100
#SBATCH --account=kempner_bsabatini_lab
#SBATCH --time=2:00:00
# Output log file (not an array job, so no %a needed):
#SBATCH --output=/n/home06/tbush/job_logs/%x.%A.out

set -eo pipefail
INPUT_FILE=$1
OUTPUT_DIR=$2

BOLTZ_CACHE="/n/holylfs06/LABS/kempner_shared/Everyone/workflow/boltz/boltz_db"
BOLTZ_OUTPUT_DIR="${OUTPUT_DIR}/boltz_output/"
export TRITON_CACHE_DIR="${SLURM_TMPDIR:-/tmp}/triton_cache_${USER}_single_job"
mkdir -p "$TRITON_CACHE_DIR"
mkdir -p "$BOLTZ_OUTPUT_DIR"

# Get script directory for wrapper
BOLTZ_WRAPPER="/n/home06/tbush/gfp_function_prediction/slrm_scripts/run_boltz_with_spawn.py"

module load python/3.12.8-fasrc01 gcc/14.2.0-fasrc01 cuda/12.9.1-fasrc01 cudnn/9.10.2.21_cuda12-fasrc01
export PATH="/n/holylfs06/LABS/kempner_shared/Everyone/common_envs/miniconda3/envs/boltz/localcolabfold/colabfold-conda/bin:$PATH"
mamba activate /n/holylfs06/LABS/kempner_shared/Everyone/common_envs/miniconda3/envs/boltz

# Set multiprocessing start method for PyTorch (must be before any torch imports)
export PYTORCH_MULTIPROCESSING_START_METHOD=spawn

# Estimate sequence length for memory optimization
# Handle both YAML and FASTA input files
if [[ "$INPUT_FILE" == *.yaml ]] || [[ "$INPUT_FILE" == *.yml ]]; then
    # Extract all sequences from YAML and sum their lengths
    SEQ_LENGTH=$(python3 <<PYTHON
import yaml
import sys
try:
    with open("$INPUT_FILE", 'r') as f:
        data = yaml.safe_load(f)
    total_length = 0
    if 'sequences' in data:
        for seq_entry in data['sequences']:
            if 'protein' in seq_entry and 'sequence' in seq_entry['protein']:
                total_length += len(seq_entry['protein']['sequence'])
    print(total_length)
except Exception as e:
    print(0, file=sys.stderr)
    sys.exit(1)
PYTHON
)
else
    # FASTA file - extract sequence length
    SEQ_LENGTH=$(grep -v "^>" "$INPUT_FILE" | tr -d '\n' | wc -c)
fi

echo "Total sequence length: ${SEQ_LENGTH} residues"

RECYCLING_STEPS=10
DIFFUSION_SAMPLES=25
NUM_WORKERS=4

# Function to run boltz with given device count
run_boltz() {
    local num_devices=$1
    local use_kernels=$2
    local extra_args=""
    local output_file=$(mktemp)
    
    if [ "$use_kernels" = "false" ]; then
        extra_args="--no_kernels"
    fi
    
    echo "Attempting prediction with ${num_devices} GPU(s), kernels=${use_kernels}"
    if python "$BOLTZ_WRAPPER" predict "$INPUT_FILE" \
        --cache "$BOLTZ_CACHE" \
        --out_dir "$BOLTZ_OUTPUT_DIR" \
        --devices "$num_devices" \
        --accelerator gpu \
        --recycling_steps "$RECYCLING_STEPS" \
        --diffusion_samples "$DIFFUSION_SAMPLES" \
        --override \
        --num_workers "$NUM_WORKERS" \
        $extra_args 2>&1 | tee "$output_file"; then
        # Check for OOM errors or failed examples
        if grep -q "ran out of memory\|Number of failed examples" "$output_file"; then
            rm -f "$output_file"
            return 1
        fi
        rm -f "$output_file"
        return 0
    else
        rm -f "$output_file"
        return 1
    fi
}

# Function to run boltz on CPU (fallback for GPU OOM)
run_boltz_cpu() {
    local use_kernels=$1
    local extra_args=""
    local output_file=$(mktemp)
    
    if [ "$use_kernels" = "false" ]; then
        extra_args="--no_kernels"
    fi
    
    echo "Attempting prediction with CPU accelerator, kernels=${use_kernels}"
    if python "$BOLTZ_WRAPPER" predict "$INPUT_FILE" \
        --cache "$BOLTZ_CACHE" \
        --out_dir "$BOLTZ_OUTPUT_DIR" \
        --accelerator cpu \
        --recycling_steps "$RECYCLING_STEPS" \
        --diffusion_samples "$DIFFUSION_SAMPLES" \
        --override \
        --num_workers "$NUM_WORKERS" \
        $extra_args 2>&1 | tee "$output_file"; then
        # Check for OOM errors or failed examples
        if grep -q "ran out of memory\|Number of failed examples" "$output_file"; then
            rm -f "$output_file"
            return 1
        fi
        rm -f "$output_file"
        return 0
    else
        rm -f "$output_file"
        return 1
    fi
}

# For very large structures (>1500 residues), try multi-GPU first to avoid OOM
# For smaller structures, prioritize single GPU (more reliable, avoids multiprocessing issues)
if [ "$SEQ_LENGTH" -gt 1500 ]; then
    echo "Very large structure detected (${SEQ_LENGTH} residues), attempting multi-GPU first to avoid OOM..."
    unset CUDA_VISIBLE_DEVICES
    
    # Try multi-GPU without kernels first (more memory efficient)
    if run_boltz 4 false; then
        echo "Boltz predictions completed successfully with 4 GPUs (no kernels)."
        exit 0
    fi
    
    # Fallback: Multi-GPU with kernels
    echo "Multi-GPU without kernels failed, trying with kernels..."
    if run_boltz 4 true; then
        echo "Boltz predictions completed successfully with 4 GPUs."
        exit 0
    fi
    
    # Fallback: Single GPU with aggressive memory settings
    echo "Multi-GPU failed, falling back to single GPU with aggressive memory settings..."
    export CUDA_VISIBLE_DEVICES=0
    if run_boltz 1 false; then
        echo "Boltz predictions completed successfully with 1 GPU (no kernels)."
        exit 0
    fi
    
    # Final fallback: CPU accelerator (slower but no GPU memory constraints)
    echo "All GPU attempts failed, falling back to CPU accelerator..."
    unset CUDA_VISIBLE_DEVICES
    if run_boltz_cpu false; then
        echo "Boltz predictions completed successfully with CPU (no kernels)."
        exit 0
    fi
else
    # For smaller structures, prioritize single GPU
    echo "Starting boltz predictions with single GPU (optimized for reliability)..."
    export CUDA_VISIBLE_DEVICES=0
    
    if run_boltz 1 true; then
        echo "Boltz predictions completed successfully with 1 GPU."
        exit 0
    fi
    
    # Fallback 1: Single GPU without kernels
    echo "Single GPU with kernels failed, trying without kernels..."
    if run_boltz 1 false; then
        echo "Boltz predictions completed successfully with 1 GPU (no kernels)."
        exit 0
    fi
    
    # Fallback 2: Try multi-GPU with ddp_spawn strategy (if single GPU fails)
    echo "Single GPU failed, attempting multi-GPU with ddp_spawn strategy..."
    unset CUDA_VISIBLE_DEVICES
    if run_boltz 4 true; then
        echo "Boltz predictions completed successfully with 4 GPUs."
        exit 0
    fi
    
    # Fallback: Multi-GPU without kernels
    echo "Multi-GPU with kernels failed, trying without kernels..."
    if run_boltz 4 false; then
        echo "Boltz predictions completed successfully with 4 GPUs (no kernels)."
        exit 0
    fi
    
    # Final fallback: CPU accelerator (slower but no GPU memory constraints)
    echo "All GPU attempts failed, falling back to CPU accelerator..."
    unset CUDA_VISIBLE_DEVICES
    if run_boltz_cpu false; then
        echo "Boltz predictions completed successfully with CPU (no kernels)."
        exit 0
    fi
fi

echo "ERROR: All boltz prediction attempts failed (including CPU fallback)!"
exit 1
